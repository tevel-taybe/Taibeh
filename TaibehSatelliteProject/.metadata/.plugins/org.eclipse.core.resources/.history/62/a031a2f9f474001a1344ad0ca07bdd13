/*
 * filesystem.c
 *
 *  Created on: 20 áîøõ 2019
 *      Author: Idan
 */

#include <hal/Timing/Time.h>
#include <hcc/api_fat.h>
#include <hal/errors.h>
#include <hcc/api_hcc_mem.h>
#include <string.h>
#include <hcc/api_mdriver_atmel_mcipdc.h>
#include <hal/Storage/FRAM.h>
#include <at91/utility/trace.h>
#include "TLM_management.h"
#include <stdlib.h>
#include <GlobalStandards.h>

#define SKIP_FILE_TIME_SEC 1000000
#define _SD_CARD 0
#define FIRST_TIME -1
#define FILE_NAME_WITH_INDEX_SIZE MAX_F_FILE_NAME_SIZE+sizeof(int)*2

//struct for filesystem info
typedef struct
{
	int num_of_files;
} FS;
//TODO remove all 'PLZNORESTART' from code!!
//struct for chain file info
typedef struct
{
	int size_of_element;
	char name[FILE_NAME_WITH_INDEX_SIZE];
	unsigned int creation_time;
	unsigned int last_time_modified;
	int num_of_files;

} C_FILE;
#define C_FILES_BASE_ADDR (FSFRAM+sizeof(FS))

int* numofelement = (int*) calloc(1, sizeof(int));
char* nameofelement = (char*) calloc(1, sizeof(char));

void delete_allTMFilesFromSD()
{
}
// return -1 for FRAM fail
static int getNumOfFilesInFS()
{
	FS fs;
	return fs.num_of_files;
}
//return -1 on fail
static int setNumOfFilesInFS(int new_num_of_files)
{
	return 0;
}
FileSystemResult InitializeFS(Boolean first_time)
{
	int ret = 0;
	hcc_mem_init();

	ret = fs_init();
	if(ret != F_NO_ERROR)
	{
		TRACE_ERROR("fs_init pb: %d\n\r", ret);
		return FS_FAT_API_FAIL;
	}
	ret = f_enterFS();

	if (ret == F_NO_ERROR)
	{
		return FS_SUCCSESS;
	}
	else
	{
		return FS_FAIL;
	}
}

//only register the chain, files will create dynamically
FileSystemResult c_fileCreate(char* c_file_name,
		int size_of_element)
{
	C_FILE a;
	F_FILE * file;
	unsigned int* time;
	unsigned int numofel = sizeof(nameofelement);
	int error = 0;

	if(strlen(c_file_name) > MAX_F_FILE_NAME_SIZE)
	{
		return FS_TOO_LONG_NAME;
	}

	file=f_open(c_file_name, "w+");
	if (!file)
	{
		return FS_NOT_EXIST;
	}

	strcpy(a.name,c_file_name);
	a.size_of_element = size_of_element;

	error = Time_getUnixEpoch(*time);

	if(error == 0)
	{
		a.creation_time = *time;
		a.last_time_modified = FIRST_TIME;
	}

	int num_of_files_in_FS = getNumOfFilesInFS();
	if(num_of_files_in_FS == -1)
	{
		return FS_FRAM_FAIL;
	}

	numofelement[numofel - 1] = 1;
	nameofelement[numofel - 1] = c_file_name;
	realloc(numofelement, numofel + (1 * sizeof(int)));
	realloc(nameofelement, numofel + (1 * sizeof(char)));
	return FS_SUCCSESS;
}
//write element with timestamp to file
static void writewithEpochtime(F_FILE* file, byte* data, int size,unsigned int time)
{
}
// get C_FILE struct from FRAM by name
static Boolean get_C_FILE_struct(char* name,C_FILE* c_file,unsigned int *address)
{
	return FALSE;
}
//calculate index of file in chain file by time
static int getFileIndex(unsigned int creation_time, unsigned int current_time)
{
	return 0;
}
//write to curr_file_name
void get_file_name_by_index(char* c_file_name,int index,char* curr_file_name)
{
}
FileSystemResult c_fileReset(char* c_file_name)
{
	F_FILE* file;
	int i = 0;
	file = fopen(c_file_name, 'w');

	for(i = 0; i < sizeof(nameofelement); i++)
	{
		if(nameofelement[i] == c_file_name)
		{
			nameofelement[i] = NULL;
			numofelement[i] = NULL;
		}
	}

	return FS_SUCCSESS;
}

FileSystemResult c_fileWrite(char* c_file_name, C_FILE* element)
{
	F_FILE* file;
	int i = 0;

	file = fopen(c_file_name, "r");
	if(file == NULL)
	{
		return FS_NOT_EXIST;
	}

	file = fopen(c_file_name, "a");
	if(f_write(element, element->size_of_element, 5, file) != 5)
	{
		f_flush(file);
		f_close(file);
		return FS_FAIL;
	}

	for(i = 0; i < sizeof(nameofelement); i++)
	{
		if(nameofelement[i] == c_file_name)
		{
			numofelement[i]++;
		}
	}
	f_flush(file);
	f_close(file);

	return FS_SUCCSESS;
}
FileSystemResult fileWrite(char* file_name, void* element,int size)
{
	return FS_SUCCSESS;
}
static FileSystemResult deleteElementsFromFile(char* file_name,unsigned long from_time,
		unsigned long to_time,int full_element_size)
{
	return FS_SUCCSESS;
}
FileSystemResult c_fileDeleteElements(char* c_file_name, time_unix from_time,
		time_unix to_time)
{
	//not finished
	F_FILE* file;
	char buffer[sizeof(C_FILE)];

	file = fopen(c_file_name, "r");
	if(file == NULL)
	{
		return FS_NOT_EXIST;
	}
	if (f_read(buffer,sizeof(C_FILE),5,file)!=sizeof(C_FILE))
	{
		return FS_FAIL;
	}


	return FS_SUCCSESS;
}
FileSystemResult fileRead(char* c_file_name,byte* buffer, int size_of_buffer,
		time_unix from_time, time_unix to_time, int* read, int element_size)
{
	return FS_SUCCSESS;
}
FileSystemResult c_fileRead(char* c_file_name,byte* buffer, int size_of_buffer,
		time_unix from_time, time_unix to_time, int* read,time_unix* last_read_time)
{
	F_FILE* file;
	unsigned int* time;
	file = fopen(c_file_name, "r");

	if(file == NULL)
	{
		return FS_NOT_EXIST;
	}

	if(sizeof(buffer) < sizeof(C_FILE))
	{
		return FS_BUFFER_OVERFLOW;
	}

	if (!f_read(buffer,sizeof(C_FILE),read,file))
	{
		return FS_FAIL;
	}
	f_close(file);

	last_read_time = Time_getUnixEpoch(*time);
	return FS_SUCCSESS;
}

int c_fileGetNumOfElements(char* c_file_name,time_unix from_time,time_unix to_time)
{

	int i = 0;
	for(i = 0; i < sizeof(nameofelement); i++)
		{
			if(nameofelement[i] == c_file_name)
			{
				return numofelement[i];
			}
		}

	return 0;


}

void print_file(char* c_file_name)
{
	F_FILE* file;
	unsigned int* time;
	unsigned int rTime = Time_getUnixEpoch(*time);
	time_unix last_read;

	file = fopen(c_file_name, "r");
	byte* buffer;
	int numOfElements = c_fileGetNumOfElements(c_file_name,FIRST_ELEMENT_IN_C_FILE,LAST_ELEMENT_IN_C_FILE);
	c_fileRead(c_file_name, buffer, sizeof(buffer),FIRST_ELEMENT_IN_C_FILE, LAST_ELEMENT_IN_C_FILE, numOfElements, &last_read);
}

void DeInitializeFS( void )
{
	int ret = fs_delete();
	if(ret != F_NO_ERROR)
	{
		TRACE_ERROR("fs_deInit pb: %d\n\r", ret);
	}

}
typedef struct{
	int a;
	int b;
}TestStruct ;
